
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <title>Vehicle Real-Time Status Tracking, Statistics and Analysis</title>
    <link rel='stylesheet' href='http://fonts.googleapis.com/css?family=Play:700,400' type='text/css'>
    <script type="text/javascript" src="http://iop.io/js/vendor/polymer/polymer.min.js"></script>
    <script type="text/javascript" src="http://iop.io/js/iopctrl.js"></script>
    <script type="text/javascript" src="/socket.io/socket.io.js"></script>
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script type="text/javascript" src="http://bl.ocks.org/tomerd/raw/1499279/gauge.js"></script>
    <script type="text/javascript" src="http://dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0"></script>
    <script>
        var directionsManager;
        var directionsErrorEventObj;
        var directionsUpdatedEventObj;
        var map = null;
        var latitude = 40.77118;
        var longitude = -73.99447;
        var greenLayer;

        var websockHost = window.location.hostname;
        var socket = io.connect('http://' + websockHost);

        function createMap() {
            //var mapOptions = { credentials: "Av2RFPnAOaHPcE1ww8BYmemHFRYfLeuDdBRgglBlXTLI0AbzU7CVA1hGcIZv-1T-" }
            var mapOptions =
            {
                credentials: "Av2RFPnAOaHPcE1ww8BYmemHFRYfLeuDdBRgglBlXTLI0AbzU7CVA1hGcIZv-1T-",
                mapTypeId: Microsoft.Maps.MapTypeId.road,
                center: new Microsoft.Maps.Location(latitude, longitude),
                zoom: 13,
                labelOverlay: Microsoft.Maps.LabelOverlay.hidden
            }
            map = new Microsoft.Maps.Map(document.getElementById("mapDiv"), mapOptions);
            registerClusterModule();

        }
        function createDirectionsManager() {
            var displayMessage;
            if (!directionsManager) {
                directionsManager = new Microsoft.Maps.Directions.DirectionsManager(map);
                displayMessage = 'Directions Module loaded\n';
                displayMessage += 'Directions Manager loaded';
            }
            //alert(displayMessage);
            directionsManager.resetDirections();
            directionsErrorEventObj = Microsoft.Maps.Events.addHandler(directionsManager, 'directionsError', function (arg) { });
            directionsUpdatedEventObj = Microsoft.Maps.Events.addHandler(directionsManager, 'directionsUpdated', function () { });
        }
        var mapData = [];
        function createDrivingRoute() {
            if (!directionsManager) { createDirectionsManager(); }
            directionsManager.resetDirections();
            // Set Route Mode to driving
            directionsManager.setRequestOptions({ routeMode: Microsoft.Maps.Directions.RouteMode.driving })

            for (var i = 0; i < mapData.length; i++) {

                if (i == 0) {
                    map.setView({ zoom: 10, center: new Microsoft.Maps.Location(mapData[i].lat, mapData[i].lon) });

                }
                directionsManager.addWaypoint(new Microsoft.Maps.Directions.Waypoint({ location: new Microsoft.Maps.Location(mapData[i].lat, mapData[i].lon) }))
            }

            /* var seattleWaypoint = new Microsoft.Maps.Directions.Waypoint({ address: 'hongqiao, SH', location: new Microsoft.Maps.Location(latitude - 2, longitude - 2) });
                directionsManager.addWaypoint(seattleWaypoint);
                var tacomaWaypoint = new Microsoft.Maps.Directions.Waypoint({ address: 'pudong, SH', location: new Microsoft.Maps.Location(latitude, longitude) });
                directionsManager.addWaypoint(tacomaWaypoint);

                var tacomaWaypoint2 = new Microsoft.Maps.Directions.Waypoint({ address: 'zhangjiang, SH', location: new Microsoft.Maps.Location(latitude + 1, longitude + 1) });
                directionsManager.addWaypoint(tacomaWaypoint2);*/
            // Set the element in which the itinerary will be rendered
            directionsManager.setRenderOptions({ itineraryContainer: document.getElementById('directionsItinerary') });

            directionsManager.calculateDirections();
        }

        function createDirections() {

            for (var i = 0; i < mapData.length; i++) {

            }

            if (!directionsManager) {
                Microsoft.Maps.loadModule('Microsoft.Maps.Directions', { callback: createDrivingRoute });
            }
            else {
                mapData = [{ "lon": longitude, "lat": latitude }, { "lon": longitude - 2, "lat": latitude - 2 }, { "lon": longitude + 1, "lat": latitude + 1 }];
                createDrivingRoute();
            }
        }
        var locationCount = 120;
        var currentlat = 0; var currentlon = 0;
        socket.on('coordinates', function (driveinfo) {
            var d = jQuery.parseJSON(driveinfo);

            if (currentlat != 0 && currentlon != 0) {
                if (currentlat != d.lat || currentlon != d.lon) {
                    if (locationCount == 0) {
                        locationCount = 120;
                        map.entities.clear();
                    }
                    locationCount--;
                    var polyline = new Microsoft.Maps.Polyline([new Microsoft.Maps.Location(d.lon * 1, d.lat * 1), new Microsoft.Maps.Location(currentlon * 1, currentlat * 1)], null);
                    map.entities.push(polyline);
                    //document.getElementById("message").innerHTML = "lon=" + d.lon + " lat=" + d.lat;
                    //latlon = map.getCenter();
                    //var polyline = new Microsoft.Maps.Polyline([new Microsoft.Maps.Location(40.77334, -73.99312), new Microsoft.Maps.Location(40.77375, -73.99290)], null);

                    //map.entities.push(polyline);
                    map.setView({ zoom: 15, center: new Microsoft.Maps.Location(currentlon * 1, currentlat * 1) })
                }
            }
            currentlat = d.lat; currentlon = d.lon;

        });
    </script>
    <style>
                body {
                    font: 16px arial;
                    background:#072a29;
                    color:#fff;
                }

                .unselectable {
                    -moz-user-select: -moz-none;
                    -khtml-user-select: none;
                    -webkit-user-select: none;
                    -ms-user-select: none;
                    user-select: none;
                }

                /* css formats for the gauge */
                .gauge .domain {
                    stroke-width: 2px;
                    stroke: #fff;
                }

                .gauge .tick line {
                    stroke: #fff;
                    stroke-width: 2px;
                }

                .gauge line {
                    stroke: #fff;
                }

                .gauge .arc, .gauge .cursor {
                    opacity: 0;
                }

                .gauge .major {
                    fill: #fff;
                    font-size: 20px;
                    font-family: 'Play', verdana, sans-serif;
                    font-weight: normal;
                }

                .gauge .indicator {
                    stroke: #EE3311;
                    fill: #000;
                    stroke-width: 4px;
                }

                /* css formats for the segment display */
                .segdisplay .on {
                    fill: #00FFFF;
                }

                .segdisplay .off {
                    fill: #00FFFF;
                    opacity: 0.15;
                }

                .chartul path {
                    stroke: steelblue;
                    stroke-width: 4;
                    fill: none;
                }

                    .chartul path.slice {
                        stroke-width: 4px;
                    }

                #rpmgraph1, #rpm path {
                    stroke: orange;
                    stroke-width: 4;
                    fill: none;
                }

                polyline {
                    opacity: .3;
                    stroke: black;
                    stroke-width: 2px;
                    fill: none;
                }


                .chartul {
                    list-style-type: none;
                    margin: 0px;
                    padding: 0px;
                }

                    .chartul li {
                        padding: 0px;
                        margin: 0px;
                        display: inline-block;
                        width: 205px;
                        height: 200px;
                    }
                #chart3 svg {
        height:110px;
                }
                 #mapDiv:before {
                    content: "";
                    width: 50%;
                    height: 50%;
                    left: 0;
                    top: 0;
                    box-shadow: -20px -30px 15px rgba(0,0,0,0.2);
                    -moz-transform: skewX(10deg) skewY(10deg) translate(40px,30px);
                    -webkit-transform: skew(10deg,10deg) translate(40px,30px);
                    -ms-transform: skew(10deg,10deg) translate(40px,30px);
                    -o-transform: skew(10deg,10deg) translate(40px,30px);
                    transform: skew(10deg,10deg) translate(40px,30px);
                }

                #mapDiv:after {
                    content: "";
                    width: 50%;
                    height: 50%;
                    right: 0;
                    top: 50%;
                    box-shadow: 20px 30px 15px rgba(0,0,0,0.2);
                    -webkit-transform: skew(10deg,10deg) translate(-40px,-20px);
                    -moz-transform: skewX(10deg) skewY(10deg) translate(-40px,-20px);
                    -ms-transform: skew(10deg,10deg) translate(-40px,-20px);
                    -o-transform: skew(10deg,10deg) translate(-40px,-20px);
                    transform: skew(10deg,10deg) translate(-40px,-20px);
                }
                /* book style */
                #mapDiv {
                    background: #fff;
                    background: -moz-linear-gradient(100% 50%, #fff, #fff 10%, #f3f3f3);
                    background: -webkit-linear-gradient(100% 50%, #fff, #fff 10%, #f3f3f3);
                    border: 1px solid #ccc;
                    -webkit-box-shadow: 1px 1px 4px rgba(0,0,0, 0.1);
                    -moz-box-shadow: 1px 1px 4px rgba(0,0,0, 0.1);
                    box-shadow: 1px 1px 4px rgba(0,0,0, 0.1);
                    -webkit-border-bottom-right-radius: 60px 5px;
                    -moz-border-radius-bottomright: 60px 5px;
                    border-bottom-right-radius: 60px 5px;
                }

                    #demo4 li:nth-of-type(4):before {
                        content: "";
                        width: 98%;
                        height: 98%;
                        left: 0;
                        top: 0;
                        background-color: #fff;
                        border: 1px solid #ccc;
                        -webkit-transform: skew(4deg, 2deg) translate(6px, 7px);
                        -moz-transform: skewX(4deg) skewY(2deg) translate(6px, 7px);
                        -ms-transform: skew(4deg, 2deg) translate(6px, 7px);
                        -o-transform: skew(4deg, 2deg) translate(6px, 7px);
                        transform: skew(4deg, 2deg) translate(6px, 7px);
                        -webkit-border-bottom-right-radius: 60px 5px;
                        -moz-border-radius-bottomright: 60px 5px;
                        border-bottom-right-radius: 60px 5px;
                    }

                    #demo4 li:nth-of-type(4):after {
                        content: "";
                        width: 98%;
                        height: 98%;
                        left: 0;
                        top: 0;
                        background-color: #fff;
                        border: 1px solid #ccc;
                        -webkit-transform: skew(3deg, 1deg) translate(4px, 4px);
                        -moz-transform: skewX(3deg) skewY(1deg) translate(4px, 4px);
                        -ms-transform: skew(3deg, 1deg) translate(4px, 4px);
                        -o-transform: skew(3deg, 1deg) translate(4px, 4px);
                        transform: skew(3deg, 1deg) translate(4px, 4px);
                    }
                /* stick style */
                #demo4 li:nth-of-type(5) {
                    -webkit-box-shadow: 0 0 5px rgba(0,0,0,0.3);
                    -moz-box-shadow: 0 0 5px rgba(0,0,0,0.3);
                    box-shadow: 0 0 5px rgba(0,0,0,0.3);
                }

                    #demo4 li:nth-of-type(5):before {
                        content: "";
                        width: 110px;
                        height: 30px;
                        background-color: rgba(255,255,0,0.2);
                        z-index: 1;
                        top: 8px;
                        left: -32px;
                        box-shadow: 0 0 5px rgba(0,0,0,0.3);
                        -webkit-transform: rotate(-45deg);
                        -moz-transform: rotate(-45deg);
                        -ms-transform: rotate(-45deg);
                        -o-transform: rotate(-45deg);
                        transform: rotate(-45deg);
                    }

                    #demo4 li:nth-of-type(5):after {
                        content: "";
                        width: 110px;
                        height: 30px;
                        background-color: rgba(255,255,0,0.2);
                        z-index: 1;
                        bottom: 8px;
                        right: -32px;
                        box-shadow: 0 0 5px rgba(0,0,0,0.3);
                        -webkit-transform: rotate(-45deg);
                        -moz-transform: rotate(-45deg);
                        -ms-transform: rotate(-45deg);
                        -o-transform: rotate(-45deg);
                        transform: rotate(-45deg);
                    }
    </style>
</head>

<body onload="createMap();">
    <div style="margin: auto;width:1700px; background: url('bg2.png') no-repeat;padding-top:10px;">
        <div style="margin: auto;width:1700px;">
            <img src="img/logo.png" /><br />
            <h2 style="padding-left:7px;">Vehicle Real-Time Status Tracking, Statistics and Analysis</h2>
        </div>

        <div style="margin: auto; width: 1700px; padding-left:7px;">
            <div style="width:600px;float:left;">
                <div id='mapDiv' style="position:absolute; width:635px; height:725px;margin:40px 0px 0px 0px;"></div>
            </div>
            <div style="width:1050px;float:right;padding:40px 0px 0px 0px;">
<div>
<div style="width:460px; float:left;">
<ul class="chartul">

                    <li style="width: 450px; height: 110px;">
                        <div style="text-align:center;">Speed [0 ~ 100] (km/h)</div>
                        <div id="graph1" class="aGraph" style="width:450px; height:110px;"></div>
                    </li>
                    <li style="width: 450px; height: 110px;">
                        <div style="text-align:center;">RPM [0 ~ 2000] (r/min)</div>
                        <div id="rpmgraph1" class="aGraph" style="width:450px; height:110px;"></div>
                    </li>
                    <div style="clear:both;"></div>
                    <div>
                        <div style="width: 120px; height: 110px; float: left;"><span id="temperature2"></span></div>
                        <div style="width: 120px; height: 110px; margin-bottom: 0px; float: left;">
                            <span id="rpm"></span>
                        </div>
                        <div style="width: 200px; height: 110px;padding-top:0px;margin-top:0px;float:left;">
                            <div id="chart3" style="padding-top:0px;margin-top:0px;"></div>
                            <div style="text-align:center;">Gear</div>
                        </div>
                        <div style="clear:both;"></div>
                    </div>
                    <li style="width:450px;height:300px;margin-bottom:25px">
                        <span id="Temperature1" style="margin-left:55px;"></span>
                        <div style="text-align:center;">Speed [0 ~ 100] (km/h)</div>
                    </li>
                </ul>
</div>
<div style="width:580px; float:right;">
				<p style="padding-left:2px;"><a href="http://storm.incubator.apache.org/documentation/Home.html">Storm</a> is a distributed real-time computation system. Similar to how Hadoop provides a set of general primitives for doing batch processing, Storm provides a set of general primitives for doing real-time computation. Storm is simple, can be used with any programming language, is used by many companies.</p>
				<p style="padding-left:2px;"><a href="http://kafka.apache.org/">Kafka</a> is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.</p>
				<p style="padding-left:2px;">This example shows how to deploy a Storm topology that reads data from the Kafka messaging system. You can use the Kafka client application to send vehicle real-time information from anywhere to the Kafka cluster. The Storm topology will translate those coordinates into JSON objects, use GeoJSON to identify the coordinates on the Bing map, and then keep a running record of Vehicle’s speed, temperature, RPM and gear usage rate. For persistence, the real-time data is stored in Microsoft Azure Table Storage service. The topology also writes data to Redis, which is how this web application gets the data. This web app is written in Node.js, uses Socket.IO and the express web application framework to read the data from Redis and display it via d3js.</p>
</div>
<div style="clear:both"></div>
</div>
                
            </div>
        </div>
        <div style="clear:both"></div>
	
	</div>
    <script>
        var websockHost = window.location.hostname;
        var socket = io.connect('http://' + websockHost);
        function chart1() {
            var svg = d3.select("#Temperature1")
                    .append("svg:svg")
                    .attr("width", 400)
                    .attr("height", 300);

            //	socket.on('coordinates', function(data){
            //	var d = jQuery.parseJSON(data);

            var gauge = iopctrl.arcslider()
                    .radius(120)
                    .events(false)
                    .indicator(iopctrl.defaultGaugeIndicator);
            gauge.axis().orient("in")
                    .normalize(true)
                    .ticks(12)
                    .tickSubdivide(3)
                    .tickSize(10, 8, 10)
                    .tickPadding(5)
                    .scale(d3.scale.linear()
                            .domain([0, 160])
                            .range([-3 * Math.PI / 4, 3 * Math.PI / 4]));

            var segDisplay = iopctrl.segdisplay()
                    .width(80)
                    .digitCount(6)
                    .negative(false)
                    .decimals(0);

            svg.append("g")
                    .attr("class", "segdisplay")
                    .attr("transform", "translate(130, 200)")
                    .call(segDisplay);

            svg.append("g")
                    .attr("class", "gauge")
                    .call(gauge);

            socket.on('coordinates', function (data) {
                var d = jQuery.parseJSON(data);

                segDisplay.value(d.speed);
                gauge.value(d.speed);

            });
        }
        function chart2() {
            function displayGraphExample(id, width, height, interpolation, animate, updateDelay, transitionDelay) {
                // create an SVG element inside the #graph div that fills 100% of the div
                var graph = d3.select(id).append("svg:svg").attr("width", "100%").attr("height", "100%");

                // create a simple data array that we'll plot with a line (this array represents only the Y values, X will just be the index location)
                //var data = [3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 3, 6, 3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 9];
                var data = [];
                // X scale will fit values from 0-10 within pixels 0-100
                var x = d3.scale.linear().domain([0, 70]).range([-5, width]); // starting point is -5 so the first value doesn't show and slides off the edge as part of the transition
                // Y scale will fit values from 0-10 within pixels 0-100
                var y = d3.scale.linear().domain([0, 160]).range([height, 0]);

                // create a line object that represents the SVN line we're creating
                var line = d3.svg.line()
                    // assign the X function to plot our line as we wish
                    .x(function (d, i) {
                        // verbose logging to show what's actually being done
                        //console.log('Plotting X value for data point: ' + d + ' using index: ' + i + ' to be at: ' + x(i) + ' using our xScale.');
                        // return the X coordinate where we want to plot this datapoint
                        return x(i);
                    })
                    .y(function (d) {
                        // verbose logging to show what's actually being done
                        //console.log('Plotting Y value for data point: ' + d + ' to be at: ' + y(d) + " using our yScale.");
                        // return the Y coordinate where we want to plot this datapoint
                        return y(d);
                    })
                    .interpolate(interpolation)

                // display the line by appending an svg:path element with the data line we created above
                graph.append("svg:path").attr("d", line(data));
                // or it can be done like this
                //graph.selectAll("path").data([data]).enter().append("svg:path").attr("d", line);


                function redrawWithAnimation() {
                    // update with animation
                    graph.selectAll("path")
                        .data([data]) // set the new data
                        .attr("transform", "translate(" + x(1) + ")") // set the transform to the right by x(1) pixels (6 for the scale we've set) to hide the new value
                        .attr("d", line) // apply the new data values ... but the new value is hidden at this point off the right of the canvas
                        .transition() // start a transition to bring the new value into view
                        .ease("linear")
                        .duration(transitionDelay) // for this demo we want a continual slide so set this to the same as the setInterval amount below
                        .attr("transform", "translate(" + x(0) + ")"); // animate a slide to the left back to x(0) pixels to reveal the new value

                    /* thanks to 'barrym' for examples of transform: https://gist.github.com/1137131 */
                }

                socket.on('coordinates', function (driveinfo) {
                    var d = jQuery.parseJSON(driveinfo);
                    data.push(d.speed);
                    if (data.length > 140) {
                        var v = data.shift();
                    }
                    redrawWithAnimation();
                });
            }

            displayGraphExample("#graph1", 225, 80, "basis", true, 1000, 1000);
        }
        function chart3() {
            var svg = d3.select("#chart3")
            .append("svg")
            .append("g")

            svg.append("g")
                    .attr("class", "slices");
            svg.append("g")
                    .attr("class", "labels");
            svg.append("g")
                    .attr("class", "lines");

            var width = 225,
                    height = 100,
                    radius = Math.min(width, height) / 2;

            var pie = d3.layout.pie()
                    .sort(null)
                    .value(function (d) {
                        return d.value;
                    });

            var arc = d3.svg.arc()
                    .outerRadius(radius * 0.8)
                    .innerRadius(radius * 0.4);

            var outerArc = d3.svg.arc()
                    .innerRadius(radius * 0.9)
                    .outerRadius(radius * 0.9);

            svg.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

            var key = function (d) { return d.data.label; };

            var color = d3.scale.ordinal()
                    .domain(["0", "1", "2", "3", "N", "R"])
                    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

            function change(data) {

                /* ------- PIE SLICES -------*/
                var slice = svg.select(".slices").selectAll("path.slice")
                        .data(pie(data), key);

                slice.enter()
                        .insert("path")
                        .style("fill", function (d) { return color(d.data.label); })
                        .attr("class", "slice");

                slice
                        .transition().duration(1000)
                        .attrTween("d", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            return function (t) {
                                return arc(interpolate(t));
                            };
                        })

                slice.exit()
                        .remove();

                /* ------- TEXT LABELS -------*/

                var text = svg.select(".labels").selectAll("text")
                        .data(pie(data), key);

                text.enter()
                        .append("text")
                        .attr("dy", ".35em")
                        .text(function (d) {
                            return d.data.label;
                        });

                function midAngle(d) {
                    return d.startAngle + (d.endAngle - d.startAngle) / 2;
                }

                text.transition().duration(1000)
                        .attrTween("transform", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            return function (t) {
                                var d2 = interpolate(t);
                                var pos = outerArc.centroid(d2);
                                pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                                return "translate(" + pos + ")";
                            };
                        })
                        .styleTween("text-anchor", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            return function (t) {
                                var d2 = interpolate(t);
                                return midAngle(d2) < Math.PI ? "start" : "end";
                            };
                        });

                text.exit()
                        .remove();

                /* ------- SLICE TO TEXT POLYLINES -------*/

                var polyline = svg.select(".lines").selectAll("polyline")
                        .data(pie(data), key);

                polyline.enter()
                        .append("polyline");

                polyline.transition().duration(1000)
                        .attrTween("points", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            return function (t) {
                                var d2 = interpolate(t);
                                var pos = outerArc.centroid(d2);
                                pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
                                return [arc.centroid(d2), outerArc.centroid(d2), pos];
                            };
                        });

                polyline.exit()
                        .remove();
            };
            var count0 = 0; var count1 = 0; var count2 = 0; var count3 = 0; var countN = 0; var countR = 0;

            socket.on('coordinates', function (driveinfo) {
                var d = jQuery.parseJSON(driveinfo);

                if (d.gear == "0") {
                    count0 = count0 + 1;
                }
                else if (d.gear == "1") {
                    count1 = count1 + 1;
                }
                else if (d.gear == "2") {
                    count2 = count2 + 1;
                }
                else if (d.gear == "3") {
                    count2 = count2 + 1;
                }
                else if (d.gear == "N") {
                    countN = countN + 1;
                }
                else if (d.gear == "R") {
                    countN = countN + 1;
                }
                var testData = [{ label: "0", value: count0 }, { label: "1", value: count1 }, { label: "2", value: count2 }, { label: "3", value: count3 }, { label: "N", value: countN }, { label: "R", value: countR }]
                change(testData);
            });

        }
        function chart4() {
            var gauges = [];
            function createGauge(name, label, min, max) {
                var config =
                {
                    size: 120,
                    label: label,
                    min: undefined != min ? min : 0,
                    max: undefined != max ? max : 100,
                    minorTicks: 5
                }

                var range = config.max - config.min;
                config.yellowZones = [{ from: config.min + range * 0.75, to: config.min + range * 0.9 }];
                config.redZones = [{ from: config.min + range * 0.9, to: config.max }];

                gauges[name] = new Gauge(name, config);
                gauges[name].render();
            }

            function createGauges() {
                createGauge("temperature2", "Temp");
            }

            function updateGauges() {
                //设置温度
                //gauges["temperature2"].redraw(100);
            }

            function getRandomValue(gauge) {
                var overflow = 0; //10;
                return gauge.config.min - overflow + (gauge.config.max - gauge.config.min + overflow * 2) * Math.random();
            }

            function initialize() {
                createGauges();
                //setInterval(updateGauges, 5000);
            }
            initialize();
            socket.on('coordinates', function (data) {
                var d = jQuery.parseJSON(data);
                gauges["temperature2"].redraw(d.temperature);
            });
        }
        function chart5() {
            var gauges = [];
            function createGauge(name, label, min, max) {
                var config =
                {
                    size: 120,
                    label: label,
                    min: undefined != min ? min : 0,
                    max: undefined != max ? max : 2000,
                    minorTicks: 5
                }

                var range = config.max - config.min;
                config.yellowZones = [{ from: config.min + range * 0.75, to: config.min + range * 0.9 }];
                config.redZones = [{ from: config.min + range * 0.9, to: config.max }];

                gauges[name] = new Gauge(name, config);
                gauges[name].render();
            }

            function createGauges() {
                createGauge("rpm", "RPM");
            }

            function updateGauges() {
                //set
                //gauges["temperature2"].redraw(100);
            }

            function getRandomValue(gauge) {
                var overflow = 0; //10;
                return gauge.config.min - overflow + (gauge.config.max - gauge.config.min + overflow * 2) * Math.random();
            }

            function initialize() {
                createGauges();
                //setInterval(rpm, 5000);
            }
            initialize();
            socket.on('coordinates', function (data) {
                var d = jQuery.parseJSON(data);
                gauges["rpm"].redraw(d.rpm);
            });
        }
        function chart6() {
            function displayGraphExample(id, width, height, interpolation, animate, updateDelay, transitionDelay) {
                // create an SVG element inside the #graph div that fills 100% of the div
                var graph = d3.select(id).append("svg:svg").attr("width", "100%").attr("height", "100%");

                // create a simple data array that we'll plot with a line (this array represents only the Y values, X will just be the index location)
                //var data = [3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 3, 6, 3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 9];
                var data = [];
                // X scale will fit values from 0-10 within pixels 0-100
                var x = d3.scale.linear().domain([0, 70]).range([-5, width]); // starting point is -5 so the first value doesn't show and slides off the edge as part of the transition
                // Y scale will fit values from 0-10 within pixels 0-100
                var y = d3.scale.linear().domain([0, 160]).range([height, 0]);

                // create a line object that represents the SVN line we're creating
                var line = d3.svg.line()
                    // assign the X function to plot our line as we wish
                    .x(function (d, i) {
                        // verbose logging to show what's actually being done
                        //console.log('Plotting X value for data point: ' + d + ' using index: ' + i + ' to be at: ' + x(i) + ' using our xScale.');
                        // return the X coordinate where we want to plot this datapoint
                        return x(i);
                    })
                    .y(function (d) {
                        // verbose logging to show what's actually being done
                        //console.log('Plotting Y value for data point: ' + d + ' to be at: ' + y(d) + " using our yScale.");
                        // return the Y coordinate where we want to plot this datapoint
                        return y(d);
                    })
                    .interpolate(interpolation)

                // display the line by appending an svg:path element with the data line we created above
                graph.append("svg:path").attr("d", line(data));
                // or it can be done like this
                //graph.selectAll("path").data([data]).enter().append("svg:path").attr("d", line);


                function redrawWithAnimation() {
                    // update with animation
                    graph.selectAll("path")
                        .data([data]) // set the new data
                        .attr("transform", "translate(" + x(1) + ")") // set the transform to the right by x(1) pixels (6 for the scale we've set) to hide the new value
                        .attr("d", line) // apply the new data values ... but the new value is hidden at this point off the right of the canvas
                        .transition() // start a transition to bring the new value into view
                        .ease("linear")
                        .duration(transitionDelay) // for this demo we want a continual slide so set this to the same as the setInterval amount below
                        .attr("transform", "translate(" + x(0) + ")"); // animate a slide to the left back to x(0) pixels to reveal the new value

                    /* thanks to 'barrym' for examples of transform: https://gist.github.com/1137131 */
                }

                socket.on('coordinates', function (driveinfo) {
                    var d = jQuery.parseJSON(driveinfo);
                    data.push(d.rpm / 300);
                    if (data.length > 140) {
                        var v = data.shift();
                    }
                    redrawWithAnimation();
                });
            }

            displayGraphExample("#rpmgraph1", 225, 80, "basis", true, 1000, 1000);
        }
        chart1();
        chart2();
        chart3();
        chart4();
        chart5();
        chart6();
    </script>
</body>

</html>
